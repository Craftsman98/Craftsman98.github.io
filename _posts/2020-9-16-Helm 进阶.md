# Helm 进阶

## 内置对象

* `Release` 
  * `Release.Name`
  * `Release.Namespace`
  * `Release.IsUpgrade` 如果是upgrade或rollback，则为true
  * `Release.IsInstall`
  * `Release.Revision` 这个Release的修订号，在安装时，这是1，并且随着每次升级和回滚而增加。 
  * `Release.Service` 渲染当前模板的服务，在Helm中，始终为Helm
* `Values` 通过`values.yaml`文件或用户提供的文件传递给模板的值。默认为空
* `Chart`  包含了`Chart.yaml`文件的内容
* `Files`对chart中所有非特殊文件的访问。
  * `Files.Get` 通过名称获取特定的文件
  * `Files.GetBytes` 以字节数组的方式（而是不是String）获取文件内容
  * `Files.Glob` 返回名称匹配给定的shell glob pattern的文件列表
  * `Files.Lines` 一行一行的读取文件
  * `Files.AsSecerts` 将文件内容返回为Base64编码后的字符串
  * `Files.AsConfig` 将文件内容返回为YAML map
* `Capabilities` 提供了kubernetes集群支持哪些能力的信息
  * `Capabilities.APIVersions`
  * `Capabilities.APIVersions.Has $version` 指示某个版本（例如batch/v1）或者资源（例如 app/v1/Deployment）在集群中是否可用
  * `Capabilities.KubeVersion`或`Capabilities.KubeVersion.Version` kubernetes的版本
  * `Capabilities.KubeVersion.Major`
  * `Capabilities.KubeVersion.Minor`

* `Template` 包含了当前被执行的template的信息
  * `Template.Name`  当前模板的命名空间文件路径 （如  mychart/templates/mytemplate.yaml ）
  * `Template.BasePath` 当前模板所在目录在Chart中的路径 （如  mychart/templates）

## values文件

**values的来源有以下四种，优先级依次增加：**

* chart中的`values.yaml`文件
* 如果这是一个子chart，父chart中的`values.yaml`文件
* `helm install`或`helm upgrade`使用了`-f`标志所提供的值文件
* 使用`--set`单独设置的参数

### 删除一个默认的key

如果想要从默认的values中删除一个key，需要重写这个key的值为`null`，这样Helm就会从覆盖的值合并中删除这个key。

```sh
helm install stable/drupal --set image=my-registry/drupal:0.1.0 --set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt] --set livenessProbe.httpGet=null
```

## Template Function 和Pipelines

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ quote .Values.favorite.drink }}
  food: {{ quote .Values.favorite.food }}
```

模板中使用 `functionName arg1 arg2...`这种语法。在上面的片段中`quote .Values.favorite.drink`就是`quote`函数并为其传递了一个参数。

Helm有60多种可用的函数，其中一部分是 [Go template language](https://godoc.org/text/template) 自身定义的，其余绝大多数都是 [Sprig template library](https://masterminds.github.io/sprig/) 的一部分

**[查看Helm提供的各种函数](https://helm.sh/docs/chart_template_guide/function_list/ )**

### Pipelines

管道是这个模板语言的一个强大的特性。类似于UNIX中的概念，管道是一种工具，用于将一系列的模板命令连接在一起，紧凑的表达一系列的转换。换句话说，管道是一种按照顺序完成多项任务的有效方式。

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | quote }}
  food: {{ .Values.favorite.food | quote }}
```

上例中，并没有使用 `quote ARGUMENT`，而是颠倒了顺序，将参数使用管道（ | ）“传送”给了函数， `.Values.favorite.drink | quote` 。使用管道，还可以将几个函数链接起来。

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
```

渲染求值之后，模板会产生如下文件：

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: trendsetting-p-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"
```

像这样的管道参数`.Values.favorite.drink | repeat 5 | quote`，第一个求值结果（` .Values.favorite.drink `）将作为最后一个参数发送给函数（含有多个参数，如` repeat COUNT STRING `）

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | repeat 5 | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
```

结果为：

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: melting-porcup-configmap
data:
  myvalue: "Hello World"
  drink: "coffeecoffeecoffeecoffeecoffee"
  food: "PIZZA"
```

### 使用`default`函数

一个被经常使用的函数就是`default`函数：` default DEFAULT_VALUE GIVEN_VALUE `。这个函数允许你在模板内部声明一个默认值，以防止该值被省略。

```yaml
drink: {{ .Values.favorite.drink | default "tea" | quote }}
```

在实际的Chart中，所有的静态默认值都应该储存在values.yaml中，不应该使用`default`来重复的指定这个值。但是`default`命令非常适合计算不能在values.yaml中声明的值。

```yaml
drink: {{ .Values.favorite.drink | default (printf "%s-tea" (include "fullname" .)) }}
```

### 使用`lookup`函数

`lookup`功能可以用来查找运行的集群中的资源。总结来说就是通过查找`  apiVersion, kind, namespace, name `来获取资源或资源列表。

| parameter  | type   |
| :--------- | :----- |
| apiVersion | string |
| kind       | string |
| namespace  | string |
| name       | string |

其中`name`和`namespace`都可以指定为空字符串来忽略。

| Behavior                               | Lookup function                            |
| :------------------------------------- | :----------------------------------------- |
| `kubectl get pod mypod -n mynamespace` | `lookup "v1" "Pod" "mynamespace" "mypod"`  |
| `kubectl get pods -n mynamespace`      | `lookup "v1" "Pod" "mynamespace" ""`       |
| `kubectl get pods --all-namespaces`    | `lookup "v1" "Pod" "" ""`                  |
| `kubectl get namespace mynamespace`    | `lookup "v1" "Namespace" "" "mynamespace"` |
| `kubectl get namespaces`               | `lookup "v1" "Namespace" "" ""`            |

当`lookup`返回一个对象时，返回的是一个字典对象，可以通过导航提取特定的值。

```go
(lookup "v1" "Namespace" "" "mynamespace").metadata.annotations
```

当`lookup`返回一个对象列表时，可以通过`item`字段获取某个对象。

```go
{{ range $index, $service := (lookup "v1" "Service" "mynamespace" "").items }}
    {{/* do something with each service */}}
{{ end }}
```

 当没有找到对象时，将返回空值。这可以用来检查对象是否存在。 

### 操作符也是函数

对于模板来说，操作符（`eq, ne, lt, gt, and, or`等等）全部都被声明为函数。在管道中，操作符可以用圆括号分组

## 流程控制

控制结构(在模板术语中称为“action”)为template作者提供了控制模板生成流程的能力。Helm的模板语言提供了以下控制结构 

* **if / else** 创建条件块
* **with** 指定作用范围
* **range** 提供类似于“for each”类型的循环

除了上述这些，还提供了一些action用来声明和使用命名模板（Named Templates）片段

* **define** 在你的模板内部声明一个新的模板
* **template** 引入一个命名模板
* **block** 声明一个特殊的可填充模板区域

### if/else

```yaml
{{ if PIPELINE }}
  # Do something
{{ else if OTHER PIPELINE }}
  # Do something else
{{ else }}
  # Default case
{{ end }}
```

PIPELINE的值为`false`有以下几种情况：

* 布尔值false
* 数值0
* 空字符串
* nil（空或null）
* 空的集合（map, slice, tuple, dict, array）

其他任何情况结果都为`true`

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | default "tea" | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
  {{ if eq .Values.favorite.drink "coffee" }}mug: true{{ end }}
```

### 控制缩进

使用`  {{- `（后面要有一个空格），消除左边的空格。使用`	 -}} ` （前面要有一个空格），消除右边的空格。**注意换行也是空白符！**

> ` {{- 3 }} `意思是消除左侧的空白符并打印“3”
>
> ` {{-3 }} ` 意思是打印“-3”

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | default "tea" | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
  {{- if eq .Values.favorite.drink "coffee" }}
  mug: true
  {{- end }}
```

同时也可以使用`indent`函数来指定缩进

```yaml
 {{ indent 2 "mug:true" }} 
```

### 使用`with`修改作用域

```yaml
{{ with PIPELINE }}
  # restricted scope
{{ end }}
```

`with`允许你设置特定的对象作为当前的作用域（`.`）。例如设置` .Values.favorites `为当前的作用域（则在这个块内`.`代表着`.Values.favorites`）

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  {{- end }}
```

注意，在受限制的作用域内，不能使用`.`获取到父作用域的其他对象。下面这种做法会导致fail。

```yaml
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  release: {{ .Release.Name }}
  {{- end }}
```

可以使用`$`符号来从父作用域中获取`Release.Name`。`$` 在模板执行开始时映射到根作用域，并且在模板执行期间它不会改变。下面这种做法是正确的。

```yaml
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  release: {{ $.Release.Name }}
  {{- end }}
```

### 使用`range`循环

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  {{- end }}
  toppings: |-
    {{- range .Values.pizzaToppings }}
    - {{ . | title | quote }}
    {{- end }}
```

在遍历每一个对象的时候，想`with`一样，`range`也会改变作用域。每次循环的作用域就是当前对象。

## 变量

在Helm模板中，变量是对另一个对象的名称引用，格式是`$name`。变量是用特殊赋值操作符`:=`来赋值的。

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- $relname := .Release.Name -}}
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  release: {{ $relname }}
  {{- end }}
```

 变量在`range`循环中特别有用。它们可以用于类似于列表的对象来捕获索引和值 （`.Values.pizzaToppings`是一个list）

```yaml
  toppings: |-
    {{- range $index, $topping := .Values.pizzaToppings }}
      {{ $index }}: {{ $topping }}
    {{- end }}
```

这将把整数索引(从0开始)分配给`$index`，把值分配给`$topping` 

```yaml
  toppings: |-
      0: mushrooms
      1: cheese
      2: peppers
      3: onions
```

对于同时拥有key和value的数据结构，可以用`range`同时获取。

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
```

运行后会得到：

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: eager-rabbit-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "pizza"
```

变量通常是局部的，如上面的例子。但是有一个特殊的变量`$`始终是全局的

```yaml
{{- range .Values.tlsSecrets }}
apiVersion: v1
kind: Secret
metadata:
  name: {{ .name }}
  labels:
    # Many helm templates would use `.` below, but that will not work,
    # however `$` will work here
    app.kubernetes.io/name: {{ template "fullname" $ }}
    # I cannot reference .Chart.Name, but I can do $.Chart.Name
    helm.sh/chart: "{{ $.Chart.Name }}-{{ $.Chart.Version }}"
    app.kubernetes.io/instance: "{{ $.Release.Name }}"
    # Value from appVersion in Chart.yaml
    app.kubernetes.io/version: "{{ $.Chart.AppVersion }}"
    app.kubernetes.io/managed-by: "{{ $.Release.Service }}"
type: kubernetes.io/tls
data:
  tls.crt: {{ .certificate }}
  tls.key: {{ .key }}
---
{{- end }}
```

## 命名模板（Named Templates）

>  A *named template* (sometimes called a *partial* or a *subtemplate*) is simply a template defined inside of a file, and given a name.  

当为模板命名的时候，需要注意模板的名称是全局的，当你声明了两个相同名称的模板，那么会使用后加载的那个模板。 因为子图表中的模板是与顶级模板一起编译的，所以您应该小心地使用特定于图表的名称来命名模板。 

### 片段（Partials）和 `_`文件

Helm中文件命名的部分规范如下：

* `template/`中的大多数文件都被视为包含Kubernetes manifests
* `NOTE.txt`是一个例外
* 但是，如果文件的名称以下划线`_`开头，则假定文件内部没有清单。这些文件没有呈现给Kubernetes对象定义，但是在其他图表模板的任何地方都可以使用。 

这种文件通常用来存储片段（Partials）和帮助（helpers）。当我们使用命令创建chart的时候，会发现一个名为`_helpers.tpl`的文件，这个文件就是模板片段的默认存储位置。

### 通过`define`和`with`声明和使用模板

`define`动作允许在模板文件内部创建一个命名模板

```yaml
{{ define "MY.NAME" }}
  # body of template here
{{ end }}
```

例如，我们可以定义一个模板来封装Kubernetes标签块

```yaml
{{- define "mychart.labels" }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
{{- end }}
```

然后可以将之前定义的模板嵌入到这个ConfigMap中，使用`template`

```yaml
{{- define "mychart.labels" }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
{{- end }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  {{- template "mychart.labels" }}
data:
  myvalue: "Hello World"
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
```

通常情况下，Helm将这些模板放在一个片段文件中，通常是`_helper.tpl`

### 设置模板的可用范围

这样引用模板时，没有向模板内传递任何范围

```yaml
{{- template "mychart.labels" }}
```

如果想要引用某些范围的对象，可以将范围传递进来

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  {{- template "mychart.labels" . }}
```

上面传递了根范围（使用`.`），也可以传递任何想要的范围（如`.Values.favorite`）

### `inlucde`函数

由于`template`是一个action而不是函数（function），所以无法将`template`的输出传递给其他的函数，数据只是简单的内联插入。

为了解决这个问题，Helm提供了一个解决方案（即`include`）来把template的内容导入到管道中进行处理。

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  labels:
{{ include "mychart.app" . | indent 4 }}
data:
  myvalue: "Hello World"
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
{{ include "mychart.app" . | indent 2 }}
```

通常认为应该使用`include`而不是`template`，这样能够更加简单且正确的输出YAML文件格式。

## 在模板中访问文件

Helm通过`.File`来访问文件，下面有几条需要注意的规则

* 可以在Helm chart中添加其他文件。这些文件会被一起打包，但是需要注意chart大小必须小于1M，这是Kubernetes对象的存储限制规定的。
* 一些文件不可以使用`.File`来访问到，通常是出于安全的考虑
  * `templates/`文件夹中的文件
  * 使用`.helmignore`排除的文件
* chart不保留UNIX模式信息，所以文件级权限不会对`.File`对象的可用性产生影响

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  {{- $files := .Files }}
  {{- range tuple "config1.toml" "config2.toml" "config3.toml" }}
  {{ . }}: |-
    {{ $files.Get . }}
  {{- end }}
```

### Path helper

Helm 从Go语言的`path`包中引用了很多有用的功能，他们都仍然使用相同的名字但是首字母小写。

引用的功能包括：

* Base
* Dir
* Ext
* IsAbs
* Clean

### Glob patterns

```yaml
{{ $currentScope := .}}
{{ range $path, $_ :=  .Files.Glob  "**.yaml" }}
    {{- with $currentScope}}
        {{ .Files.Get $path }}
    {{- end }}
{{ end }}
```

或者

```yaml
{{ range $path, $_ :=  .Files.Glob  "**.yaml" }}
      {{ $.Files.Get $path }}
{{ end }}
```

### ConfigMap和Secrets工具函数

**（Helm 2.0.2 +）**

在File类型中提供了一些工具函数如`AsConfig`、`AsSe`

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: conf
data:
{{ (.Files.Glob "foo/*").AsConfig | indent 2 }}
---
apiVersion: v1
kind: Secret
metadata:
  name: very-secret
type: Opaque
data:
{{ (.Files.Glob "bar/*").AsSecrets | indent 2 }}
```

### Encoding

 可以导入文件并使用base-64模板对其进行编码，以确保成功传输： 

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: {{ .Release.Name }}-secret
type: Opaque
data:
  token: |-
    {{ .Files.Get "config1.toml" | b64enc }}
```

### Lines

有时需要访问模板文件中的每一行，为此Helm提供了一个`Lines`函数。

```yaml
data:
  some-file.txt: {{ range .Files.Lines "foo/bar.txt" }}
    {{ . }}{{ end }}
```

## 创建一个`NOTE.txt`文件

在`helm install`或`helm update`完成的时候，Helm可以为用户提供一段有用的信息，这段信息可以使用模板来高度定制。

想要为你的chart添加一个安装后指南，只需要创建一个`templates/NOTE.txt`文件。这是一个纯文本文档，但是它像template一样被处理，并且拥有正常的template函数和对象。

```
Thank you for installing {{ .Chart.Name }}.

Your release is named {{ .Release.Name }}.

To learn more about the release, try:

  $ helm status {{ .Release.Name }}
  $ helm get all {{ .Release.Name }}
```

使用`NOTE.txt`可以极大的帮助你的用户了解如何使用新安装的chart，推荐创建`NOTE.txt`文件，当然这不是必须的。

## Debugging Templates

调试模板可能很棘手，因为渲染后的模板被发送到Kubernetes API服务器，该服务器可能会因为格式化以外的原因拒绝YAML文件。 

* `helm lint` 是验证chart是否满足最佳实践的首选工具
* `helm install --dry-run --debug `或`helm template --debug`  这是让服务器渲染模板，然后返回生成的清单文件的好方法。 

* `helm get manifest` 这是查看服务器上安装了哪些模板的好方法。 